; ============================================================================

; LIBRARY OF COMMON ROUTINES FOR IA-32 LINUX ASSEMBLY LANGUAGE -- 1.00
; Compiled by Mike Saunders (okachi@gmail.com), public domain
;
; * lib_print_string -- Print zero-terminated string pointed to by ESI
;
; * lib_input_string -- Store zero-terminated string in buffer at EDI
;
; * lib_print_number -- Print positive integer in EAX (max 4,294,967,295)
;
; * lib_input_number -- Store positive integer in EAX
;
; * lib_clear_screen -- Clear screen and return cursor to top-left
;
; * lib_exit -- Terminate program with return code in EBX


; ----------------------------------------------------------------------------

section .text

lib_print_string:
	pusha

	push esi			; Save original string pos for later

	mov edx, 0			; Counter for length of string

.loop:
	lodsb				; Get byte from string
	cmp al, 0			; Is it the zero-termination char?
	je .finished			; If so, quit out of the loop
	inc edx				; Otherwise increment our char counter
	jmp .loop			; And carry on


	; OK, we're done counting. EDX now contains the number of chars
	; in the string, which we need for the sys_write kernel call

.finished:
	pop esi				; Get original string location back
	mov ecx, esi			; And put into ECX for the kernel call
	mov eax, 4			; sys_write kernel call
	mov ebx, 1			; stdout
	int 0x80			; Call kernel

	mov eax, 4			; Print newline character too
	mov ebx, 1
	mov ecx, .newline
	mov edx, 1
	int 0x80

	popa
	ret


section .data
	.newline db 10


; ----------------------------------------------------------------------------

section .text

lib_input_string:
	pusha

	mov eax, 3			; sys_read kernel call
	mov ebx, 0			; stdin
	mov ecx, edi			; Buffer to store chars
	mov edx, 256			; Max chars to read
	int 0x80


	; OK, now the string is stored. However, the newline char (10)
	; generated by the enter key is also stored, which we don't want,
	; so we're going to replace that by zero to zero-terminate the string

	mov esi, edi

.loop:
	lodsb				; Get byte from string
	cmp al, 10			; Is it 10?
	jne .loop			; If not, keep searching


	; Now the 10 has been found, but 'lodsb' increments the ESI register,
	; so we want to step back a byte and store 0 where the 10 was

	dec esi
	mov edi, esi
	mov al, 0
	stosb

	popa
	ret


; ----------------------------------------------------------------------------

section .text

lib_print_number:
	pusha
	mov edi, .stringbuf

	mov ebx, 10			; Base of the decimal system
	mov ecx, 0			; Number of digits generated

.next_divide:
  	mov edx, 0			; EAX extended to (EDX,EAX)
	div ebx				; Divide by the number-base
	push edx			; Save remainder on the stack
	inc ecx				; And count this remainder
	cmp eax, 0			; Was the quotient zero?
	jne .next_divide		; No, do another division


	mov byte [.stringlen], cl	; Save length of string

.next_digit:

	pop eax				; Else pop recent remainder
	add al, '0'			; And convert to a numeral
	stosb				; Store to memory-buffer
	loop .next_digit		; Again for other remainders

	mov al, 10			; Store carriage return char
	stosb


	; Now write the string to the screen

	mov eax, 4			; sys_write kernel call
	mov ebx, 1			; stdout
	mov ecx, .stringbuf
	mov edx, 0
	mov byte dl, [.stringlen]
	int 0x80			; Call kernel

	mov eax, 4			; Print newline character too
	mov ebx, 1
	mov ecx, .newline
	mov edx, 1
	int 0x80

	popa
	ret


section .bss				; Data section
	.stringbuf resb 16		; String for ASCII version of number
	.stringlen resb 1		; Length of string


section .data
	.newline db 10


; ----------------------------------------------------------------------------

section .text

lib_input_number:
	pusha

	mov edi, .buffer		; First, get a text string
	call lib_input_string

	mov esi, .buffer		; And now convert it

	mov eax, 0			; Initialise accumulator
	mov ebx, 10			; Decimal-system's radix

.next_digit:
	mov cl, [esi]			; Fetch next character
	cmp cl, '0'			; Char preceeds '0'?
	jb .invalid			; Yes, not a numeral
	cmp cl, '9'			; Char follows '9'?
	ja .invalid			; Yes, not a numeral
	mul ebx				; Ten times prior sum
	and ecx, 0x0F			; Convert char to int
	add eax, ecx			; Add to prior total
	inc esi				; Advance source index
	jmp .next_digit			; And check another char
	
.invalid:
	mov long [.tmp], eax		; Get EAX back after popa
	popa
	mov long eax, [.tmp]
	ret


section .bss
	.buffer resb 32
	.tmp resb 4


; ----------------------------------------------------------------------------

section .text

lib_clear_screen:			; Clear screen using VT100 codes
	pusha

	mov eax, 4			; sys_write kernel call
	mov ebx, 1			; stdout
	mov ecx, .cls_codes		; Clear screen VT100 codes
	mov edx, 4			; Chars to print
	int 0x80			; Call kernel

	mov eax, 4
	mov ebx, 1
	mov ecx, .home_codes		; Set cursor home VT100 codes
	mov edx, 3			; Chars to print
	int 0x80			; Call kernel

	popa
	ret


section .data
	.cls_codes db 0x1B, '[', '2', 'J'
	.home_codes db 0x1B, '[', 'H'


; ----------------------------------------------------------------------------

section .text

lib_exit:
	mov eax, 1			; sys_exit kernel call
	int 0x80			; Call kernel


; ============================================================================

